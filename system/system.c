/*************************************************************************************************************
 * 文件名:	system.c
 * 功能:		S3C6410相关系统函数
 * 作者:		陈鹏
 * 创建时间:	2012年3月4日11:25
 * 最后修改时间:2012年3月4日
 * 详细:		2012年3月5日17:00 添加VIC相关函数
*************************************************************************************************************/
#include "system.h"


/*************************************************************************************************************************
*函数        :	void SetEINT_TriggerMode(u8 EINT0_N,u8 Trigger)
*功能        :	设置外部中断组0触发模式
*参数        :	EINT0_N:中断源的编号(见:中断组0编号定义);Trigger:触发模式(EXT_LowLevel:低电平触发;EXT_HighLevel:高电平触发;
					EXT_NegEdge:下降沿触发;EXT_PosEdge:上升沿触发;EXT_Edge:边沿触发)
*返回        :	无
*依赖        :	底层宏定义
*作者        :	陈鹏
*时间        :	20120304
*最后修改时间:	20120304
*说明        :	编号 GPN0--->GPN15  GPL8--->GPL14  GPM0--->GPM4,中断设置必须两个两个一起
*************************************************************************************************************************/
void SetEINT0_TriggerMode(vu8 EINT0_N,vu8 Trigger)
{	
	if(EINT0_N & 0x80) //EINT0CON1
	{
		EINT0_N -= 0x80;//减去标记
		rEINT0CON1 &= ~(7 << EINT0_N);//清楚原来的设置
		rEINT0CON1 |= Trigger << EINT0_N;
	}
	else	//EINT0CON0
	{
		rEINT0CON0 &= ~(7 << EINT0_N);//清楚原来的设置
		rEINT0CON0 |= Trigger << EINT0_N;
	}
}



/*************************************************************************************************************************
*函数        :	void Set_GateClk(u8 HCLK_DIV,u8 ENABLE)
*功能        :  CLK时钟门控设置(HCLK,PCLK,SCLK)
*参数        :  CLK_DIV:外设(见:CLK门控时钟定义);ENABLE = Enable,1使能;=Disable,0失能
*返回        :  无
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120305
*最后修改时间: 	20120305
*说明        :  PCLK_GATE添加标识0x40,SCLK_GATE添加标示0x80;
*************************************************************************************************************************/
void Set_GateClk(vu8 CLK_DIV,vu8 ENABLE)
{
	vu32 *P = &rHCLK_GATE;
	
	if(CLK_DIV & 0x80)		//SCLK
	{
		P = &rSCLK_GATE;
		CLK_DIV -= 0x80;	//去掉标示
	}
	else if(CLK_DIV & 0x40)	//PCLK
	{
		P = &rPCLK_GATE;
		CLK_DIV -= 0x40;	//去掉标示
	}
	if(ENABLE)	//使能
		*P |= 1 << CLK_DIV;
	else		//失能
		*P &= ~(1 << CLK_DIV);
}



/*************************************************************************************************************************
*函数        :	void Set_INTtoIRQ(u8 INT_N)
*功能        :  设置一个中断为IRQ
*参数        :  INT_N:中断编号(见:中断源编号定义);
*返回        :  无
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120305
*最后修改时间: 	20120305
*说明        :  设置一个中断为普通中断模式
*************************************************************************************************************************/
void Set_INTtoIRQ(vu8 INT_N)
{
	if(INT_N > 31)	//VIC1
	{
		INT_N -= 32;
		VIC1->INTSELECT &= ~(1 << INT_N);
	}
	else			//VIC0
		VIC0->INTSELECT &= ~(1 << INT_N);
}


/*************************************************************************************************************************
*函数        :	void Set_INTtoFIQ(u8 INT_N)
*功能        :  设置一个中断为FIQ
*参数        :  INT_N:中断编号(见:中断源编号定义);
*返回        :  无
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120305
*最后修改时间: 	20120305
*说明        :  设置一个中断为快速中断模式
*************************************************************************************************************************/
void Set_INTtoFIQ(vu8 INT_N)
{
	if(INT_N > 31)	//VIC1
	{
		INT_N -= 32;
		VIC1->INTSELECT |= (1 << INT_N);
	}
	else			//VIC0
		VIC0->INTSELECT |= (1 << INT_N);
}


/*************************************************************************************************************************
*函数        :	void Set_IntEnable(u8 INT_N,FunctionalState EnInt)
*功能        :  开启或关闭一个VIC中断
*参数        :  INT_N:中断编号(见:中断源编号定义),
* 			EnInt = ENABLE,1使能;=DISABLE,0失能;
*返回        :  无
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120305
*最后修改时间: 	20120305
*说明        :  使能或失能VIC0,VIC1的一个中断
*************************************************************************************************************************/
void Set_IntEnable(vu8 INT_N,FunctionalState EnInt)
{
	VICx_TypeDef *P = VIC0;
	
	if(INT_N > 31)	//VIC1
	{
		INT_N -= 32;
		P = VIC1;
	} 
	if(EnInt == ENABLE) //使能中断
		P->INTENABLE = 1 << INT_N;	//写1使能中断,写0无影响
	else		//取消中断
		P->INTENCLEAR = 1 << INT_N;	//写1清除中断使能,写0无影响
}


/*************************************************************************************************************************
*函数        :	u8 Get_IntEnable(vu8 INT_N)
*功能        :  获取一个中断屏蔽状态
*参数        :  中断编号
*返回        :  1:该中断失能,0:该中断失能
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120524
*最后修改时间: 	20120524
*说明        :  获取一个中断屏蔽状态
*************************************************************************************************************************/
u8 Get_IntEnable(vu8 INT_N)
{
	VICx_TypeDef *P = VIC0;
	
	if(INT_N > 31)	//VIC1
	{
		INT_N -= 32;
		P = VIC1;
	} 
	if(P->INTENABLE & (1 << INT_N)) //该中断使能
		return 1;
	else 
		return 0;
}


/*************************************************************************************************************************
*函数        :	void Set_SoftInt(u8 INT_N,u8 ENABLE)
*功能        :  开启或关闭一个软件中断
*参数        :  INT_N:中断编号(见:中断源编号定义),ENABLE = Enable,1使能;=Disable,0失能;
*返回        :  无
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120305
*最后修改时间: 	20120305
*说明        :  使能或失能VIC0,VIC1的一个软件中断
*************************************************************************************************************************/
void Set_SoftInt(vu8 INT_N,vu8 ENABLE)
{
	VICx_TypeDef *P = VIC0;
	
	if(INT_N > 31)	//VIC1
	{
		INT_N -= 32;
		P = VIC1;
	} 
	if(ENABLE) //使能中断
		P->SOFTINT = 1 << INT_N;	//写1使能软件中断,写0无影响
	else		//取消中断
		P->SOFTINTCLEAR = 1 << INT_N;	//写1清除软件中断使能,写0无影响
}



/*************************************************************************************************************************
*函数        :	void Set_IsrAddr(u8 INT_N,vu32 IsrAdd)
*功能        :  设置中断矢量入口
*参数        :  INT_N:中断编号(见:中断源编号定义),IsrAdd:中断服务程序指针;
*返回        :  无
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120305
*最后修改时间: 	20120311
*说明        :  设置矢量地址寄存器
*************************************************************************************************************************/
void Set_IsrAddr(vu8 INT_N,vu32 IsrAdd)
{
	VICx_TypeDef *P = VIC0;
	
	if(INT_N > 31)	//VIC1
	{
		INT_N -= 32;
		P = VIC1;
	}
	P->VECTADDR[INT_N] = IsrAdd;//将中断服务程序入口地址写入矢量地址寄存器
}


/*************************************************************************************************************************
*函数        :	void Set_VectorPriority(u8 INT_N,u8 Priority)
*功能        :  设置矢量优先级
*参数        :  INT_N:中断编号(见:中断源编号定义),Priority:优先级0-15;
*返回        :  无
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120305
*最后修改时间: 	20120305
*说明        :  优先级为0-15,值越大优先级越高,15最高,0最低;
*************************************************************************************************************************/
void Set_VectorPriority(vu8 INT_N,vu8 Priority)
{
	VICx_TypeDef *P = VIC0;
	
	if(INT_N > 31)	//VIC1
	{
		INT_N -= 32;
		P = VIC1;
	}
	P->VECTRPRIORITY[INT_N] = Priority;//将中断优先级写入寄存器
}





/*************************************************************************************************************************
*函数        :	u32 Get_PLLCLK(int pllreg)
*功能        :  获取PLL时钟频率
*参数        :  pllreg : PLL选择
					APLL 	0	//ARM内核时钟PLL
					MPLL 	1	//主时钟PLL
					EPLL 	2	//外设时钟PLL
*返回        :  频率,HZ
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120526
*最后修改时间: 	20120526
*说明        :  无
*************************************************************************************************************************/
u32 Get_PLLCLK(u8 pllreg)
{
	u32 r = 0, m, p, s;

	if (pllreg == APLL)
		r = rAPLL_CON;
	else if (pllreg == MPLL)
		r = rMPLL_CON;
	else if (pllreg == EPLL)
		r = rEPLL_CON0;

	m = (r>>16) & 0x3ff;
	p = (r>>8) & 0x3f;
	s = r & 0x7;

	return (m * (SYSTEM_MAIN_CLK_IN / (p * (1 << s))));
}


/*************************************************************************************************************************
*函数        :	u32 Get_FCLK(void)
*功能        :  获取FCLK时钟频率
*参数        :  无
*返回        :  频率,HZ
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120526
*最后修改时间: 	20120526
*说明        :  无
*************************************************************************************************************************/
u32 Get_FCLK(void)
{
	return (Get_PLLCLK(APLL));
}



/*************************************************************************************************************************
*函数        :	u32 Get_PCLK(void)
*功能        :  获取PCLK时钟频率
*参数        :  无
*返回        :  频率,HZ
*依赖        :	底层宏定义
*作者        :  陈鹏
*时间        :	20120526
*最后修改时间: 	20120526
*说明        :  无
*************************************************************************************************************************/
u32 Get_PCLK(void)
{
	u32 fclk;
	u32 hclkx2_div = ((rCLK_DIV0 >> 9) & 0x7) + 1;
	u32 pre_div = ((rCLK_DIV0 >> 12) & 0xf) + 1;

	if(rOTHERS & 0x80)
		fclk = Get_FCLK();		// SYNC Mode
	else
		fclk = Get_PLLCLK(MPLL);	// ASYNC Mode

	return fclk/(hclkx2_div * pre_div);
}












//////////////////////////////////////////////////////////////////
//???????′???,???printf????,
//PRINTF_EN == 1,?????printf??????
#if (PRINTF_EN_ == 1)
#include "uart.h" 

int fputc(int ch,FILE *f)
{     
	UART0_SendByte((u8)ch);     
	return ch;
}
#endif

//PRINTF_EN == 2,?????printf?????
#if (PRINTF_EN_== 2)
#include "tft_lcd.h"

int fputc(int ch, FILE *f)
{    
	static u16 X;
	static u16 X1;
	static u16 Y;
	static u8 flag;
 	
 	if(flag == 0)
 	{
	 	if(Y > LCD_YSIZE-1-16)
		{
			
			Y = 0;
			X = X1 = LCD_XSIZE/2;
			flag = 1;
			LCD_Fill(X1,LCD_XSIZE-1,0,LCD_YSIZE-1,0xffff);	//????????
		}
 	}
 	else
 	{
	 	if(Y > LCD_YSIZE-1-16)
		{
			Y = 0;
			X = X1 = 0;
			flag = 0;
			LCD_Fill(0,LCD_XSIZE/2-1,0,LCD_YSIZE-1,0xffff);	//????????
		}
 	}
	
	
	if((u8)ch == '\n')
	{
	 	X = X1;
		Y += 12;
	}
	else if((u8)ch > 0x80) //????
	{
		return ch;
	}
	else
	{
		LCD_Char(X,Y,(u8 *)&ch,0x0000,0xffff,0x80);
		
		if(flag == 0)
		{
			if(X > LCD_XSIZE/2-1-8)
			{
			 	X = X1;
				Y += 12;
			}
			else
				X += 8;
		}
		else
		{
			if(X > LCD_XSIZE-1-8)
			{
			 	X = X1;
				Y += 12;
			}
			else
				X += 8;
		}
	}     

	return ch;
}
#endif


//PRINTF_EN == 3,???????printf??????????
#if (PRINTF_EN_ == 3)
#include "tft_lcd.h"
#include "uart.h"
#include <locale.h>
u8 PrintfSet = 0;	//0:????printf??????;1:????printf?????

int fputc(int ch, FILE *f)
{    
	static u16 X;
	static u16 X1;
	static u16 Y;
	static u8 flag;
 	
	if(PrintfSet)
	{
		if(flag == 0)
	 	{
		 	if(Y > LCD_YSIZE-1-16)
			{
				
				Y = 0;
				X = X1 = LCD_XSIZE/2;
				flag = 1;
				LCD_Fill(X1,LCD_XSIZE-1,0,LCD_YSIZE-1,0xffff);	//????????
			}
	 	}
	 	else
	 	{
		 	if(Y > LCD_YSIZE-1-16)
			{
				Y = 0;
				X = X1 = 0;
				flag = 0;
				LCD_Fill(0,LCD_XSIZE/2-1,0,LCD_YSIZE-1,0xffff);	//????????
			}
	 	}
		
		
		if((u8)ch == '\n')
		{
		 	X = X1;
			Y += 12;
		}
		else if((u8)ch > 0x80) //????
		{
			return ch;
		}
		else
		{
			LCD_Char(X,Y,(u8 *)&ch,0x0000,0xffff,0x80);
			
			if(flag == 0)
			{
				if(X > LCD_XSIZE/2-1-8)
				{
				 	X = X1;
					Y += 12;
				}
				else
					X += 8;
			}
			else
			{
				if(X > LCD_XSIZE-1-8)
				{
				 	X = X1;
					Y += 12;
				}
				else
					X += 8;
			}
		}
	}
	else
		UART0_SendByte((u8)ch);

	return ch;
}
#endif
















/*
#define DEBUG(format, ...) printf (format, ##__VA_ARGS__)??' ## '?????????????????????????????????? preprocessor ???????????????????
??????????????????DEBUG????????printf?????е?DEBUG(??)?????????I????printf(??)??????????????????????????
?????????????????printf??????????????????????????????????????????????????????????????????????????????????4???????????????????????????????????????λ????????4?????????????????????????????????????????????????????????????4???
??????????????????????????
?????????ú?
????????????????????壬??Щ???I????????????????????????д?????????????????????????????????????????
ANSI C??????м?????????????????????
__LINE__??????????в??????????к??
__FILE__?????????в??????????
__DATE__?????????в?????????????
__TIME__?????????в???????????
__STDC__????????????????ANSI C??????????????1??
__cplusplus??????дC++????????????^
??????????????????????????????Щ???I?????????
???????????????????????????????__FILE__??__LINE__????????????????????????????????????????????
DEBUG("FILE: %s, LINE: %d??",__FILE__,__LINE__,??)
?????б????__FILE__??????????????????????? ?????????????????????
DEBUG("FILE:"__FILE__", LINE: %d??",__LINE__,??)
????????????????????????????????????????????д"FILE:"__FILE__", LINE: %d ???,__LINE,??}???????????????????????
?????????????????δ??????DEBUGд??????
DEBUG(format,...) printf("FILE: "__FILE__", LINE: %d: "format"/n", __LINE__, ##__VA_ARGS__)
?????????????????е?DEBUG???????????????????
FILE: xxx, LINE: xxx, ????.
*/

//#define DEBUG(format,...) printf("<DebugFile: "__FILE__", Line: %d> "format, __LINE__, ##__VA_ARGS__) 

/*
#include <locale.h>
setlocale(LC_ALL,"C"); //设置本地区域
*/

